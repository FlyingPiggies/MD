# 并发控制

当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作的结果是一样的。这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。

- 没有做好并发控制，就可能导致脏读，幻读，不可重复读等问题。

- 常说的并发控制，一般都和数据库管理系统（DBMS）有关。在DBMS中的并发控制的任务，是确保在多个事务同时存取数据库中同一数据时，不破坏事务的隔离性、一致性和数据库的统一性。

## 实现并发控制的主要手段大致可以分为乐观并发控制和悲观并发控制两种。

***

- 首先要明确：无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像 hibernate、tair、memcache 等都有类似的概念。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。乐观锁比较适用于读多写少的情况(多读场景)，悲观锁比较适用于写多读少的情况(多写场景)。

### 悲观锁

***

- 当要对数据库中的一条数据进行修改时，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（Pessimistic Concurrency Control）。

- 悲观锁，正如其名，具有强烈的独占性和排他性。它指的是对数据被外界修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制，也只有数据库层提供的锁机制才能真正保证数据访问的排他性。

- 实现如下

    - 传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

    - synchronized关键字的实现。

- 悲观锁主要分为共享锁和排他锁。

    - 共享锁（Shared Locks）又称为读锁，简称S锁。顾名思义，S锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读，不能修改。

    - 排他锁（Exclusive Locks）又称为写锁，简称为X锁。顾名思义，X锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改的。

- 悲观并发控制实际上是"先取锁再访问"的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制，会让数据库产生额外的开销，还有增加死锁的机会。另外还会降低并发性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。

### 乐观锁

***

- 乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，可以提高程序的吞吐量。

- 实现如下
    - 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

    - CAS：Compare and Swap



