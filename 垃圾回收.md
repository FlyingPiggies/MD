# .Net 垃圾回收

垃圾回收器管理应用程序的内存分配和释放。

## 优点

- 开发人员不必手动释放内存

- 有效分配托管堆上的对象

- 回收不再使用的对象，清楚它们的内存，并保留内存以用于将来分配。托管对象会自动获取干净的内容来开始，因此，它们的构造函数不必对每个数据字段进行初始化。

- 通过确保对象不能使用另一个对象的内容来提供内存安全。

## 内存基础知识

- 每个进程都有其自己单独的虚拟地址空间。同一台计算机上的所有进程共享相同的物理内存和页文件（如果有）

- 默认情况下，32位计算机上的每个进程都具有2GB的用户模式虚拟空间。

- 只能使用虚拟地址空间，勿直接操纵物理内存。垃圾回收器为你分配和释放托管堆上的虚拟内存。

- 虚拟内存有三种状态：

    - Free ： 该内存块没有引用关系，可用于分配。

    - Reserved : 内存块可供你使用，但是不能用于任何其他请求分配。在该内存块提交之前，你无法将数据存储其中

    - Committed : 内存块已指派给物理存储。

- 可能会存在虚拟地址空间碎片，就是说地址空间中存在一些被称为孔的可用快。当请求虚拟内存分配时，虚拟内存管理器必须找到满足该分配请求的足够大的单个可用块。

- 如果没有足够的可供保留的虚拟地址空间或可供提交的物理空间，则可能会用尽内存。

## 内存分配

初始化新进程时，运行时会为进程保留一个连续的地址空间区域。这个保留的地址空间被称为托管堆。托管堆维护着一个指针，用它指向将在堆中分配的下一个对象的地址。最初，该指针设置为指向托管堆的基址。托管堆上部署了所有引用类型。应用程序创建第一个引用类型时，将为托管堆的基址中的类型分配内存。应用程序创建下一个对象时，垃圾回收器在紧接第一个对象后面的地址空间内为它分配内存，只要地址空间可用，垃圾回收器就会继续以这种方式为新对象分配空间。

从托管堆中分配内存要比非托管内存分配速度快。由于运行时通过为指针添加值来为对象分配内存，所以这几乎和从堆栈中分配内存一样快。另外由于连续分配的新对象在托管堆中是连续存储，所有应用程序可以快速访问这些对象。

## 内存释放

- Mark-Compact（标记压缩算法）

    简单地把.NET的GC算法看作Mark-Compact算法。阶段1: Mark-Sweep 标记清除阶段，先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；阶段2: Compact 压缩阶段，对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理。

    ![](https://images.cnblogs.com/cnblogs_com/riccc/dotnet/net-mem-02-mark-compact.png)

- Generational(分代算法)

    程序可能使用几百M、几G的内存，对这样的内存区域进行GC操作成本很高，分代算法具备一定统计学基础，对GC的性能改善效果比较明显。将对象按照生命周期分成新的、老的，根据统计分布规律所反映的结果，可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度，争取在较短时间间隔、较小的内存区域内，以较低成本将执行路径上大量新近抛弃不再使用的局部对象及时回收掉。分代算法的假设前提条件：
    
    - 大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长;

    - 对部分内存进行回收比基于全部内存的回收操作要快;

    - 新创建的对象之间关联程度通常较强。heap分配的对象是连续的，关联度较强有利于提高CPU
    cache的命中率，.NET将heap分成3个代龄区域: Gen 0、Gen 1、Gen 2；

    Heap分为3个代龄区域，相应的GC有3种方式: # Gen 0 collections, # Gen 1 collections, #Gen 2 collections。如果Gen 0 heap内存达到阀值，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果Gen 1的内存达到阀值，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。
    
    2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收，Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为full GC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时，full GC可能需要花费几秒时间。大致上来讲.NET应用运行期间，2代、1代和0代GC的频率应当大致为1:10:100。

    ![](https://images.cnblogs.com/cnblogs_com/riccc/dotnet/net-mem-06-generation.png)

- Finalization Queue 和 Freachable Queue

